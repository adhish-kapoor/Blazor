# REST Constraints
=====================
When building a REST API, we have to follow a set of rules. 
These are commonly called as REST Constraints. The following are some of the common REST constraints.

1. Client Server constraint
This is the first constraint. Client sends a request and the server sends a response.
In our case Client is the Employee portal which sends a request for employee data and the server, the REST API, responds with employee data.
This separation of concerns supports the independent evolution of the client-side logic and server-side logic.

2. Stateless constraint
The communication between the client and the server must be stateless between requests. 
This means we should not be storing anything on the server related to the client.
The request from the client should contain all the necessary information for the server to process that request. 
This ensures that each request can be treated independently by the server.

3. Cacheable constraint
Some data provided by the server like list of products, or list of departments in a company does not change that often. 
This constraint says that let the client know how long this data is good for, so that the client does not have to come back to the server for that data over and over again.

4. Uniform Interface
As the name implies, this constraint defines the interface between the client and the server. 
This constraint helps us understand how a REST API actually works. 

In the context of a REST API, a resource is a data entity like Product, Employee, Customer, Order etc. 
For example, a REST API that provides employee data makes the list of employees available at the following URI (Uniform Resource Identifier).

            http://xxx.com/api/employees
         
So, each resource, is identified by a specific URI. 
For example, the list of employees are available at the URI http://pragimtech.com/api/employees.
Similarly, the list of products are available at the URI http://pragimtech.com/api/products.

# PUT V/S PATCH
==================
PUT updates the entire object i.e FirstName, LastName, DOB, Gender, Email etc of an employee. 
Basically all the properties of the object are updated.

PATCH is used when you want to do a partial update i.e only a subset of the properties. 
May be just FirstName and Gender of an employee object.

# ASP.NET Core REST API DbContext
=======================================
EF core is lightweight, extensible, and open source software. Like .NET Core, EF Core is also cross platform. 
It works on windows, Mac OS, and Linux. EF core is Microsoftâ€™s official data access platform.

Entity Framework Core DbContext class
=======================================
One of the very important classes in Entity Framework Core is the DbContext class. This is the class that we use in our application code to interact with the underlying database. It is this class that manages the database connection and is used to retrieve and save data in the database.

To use the DbContext class in our application:
1.We create a class that derives from the DbContext class.
2.DbContext class is in Microsoft.EntityFrameworkCore namespace.

public class AppDbContext : DbContext
{ }

DbContextOptions in Entity Framework Core
===============================================
For the DbContext class to be able to do any useful work, it needs an instance of the DbContextOptions class.

The DbContextOptions instance carries configuration information such as the connection string, database provider to use etc.
We pass the DbContextOptions to the base DbContext class constructor using the base keyword as shown below:

public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options)
        : base(options)
    {
    }
}

Entity Framework Core DbSet
==============================
1.The DbContext class includes a DbSet<TEntity> property for each entity in the model.
2.At the moment in our application we have, 2 entity classes - Employee and Department.
3.So in our AppDbContext class we have 2 corresponding DbSet properties.
DbSet<Employee>
DbSet<Department>

4.We will use these DbSet properties to query and save instances of Employee and Department classes.
5.The LINQ queries against the DbSet properties will be translated into queries against the underlying database.

public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options)
        : base(options)
    {
    }

    public DbSet<Employee> Employees { get; set; }
    public DbSet<Department> Employees { get; set; }
}

Seeding Data
================
Override OnModelCreating method to seed Employee and Department data.

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);
    
    // Code to seed data
}

